#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
import evernote.edam.userstore.ttypes
import evernote.edam.type.ttypes
import evernote.edam.error.ttypes
import evernote.edam.limits.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class SyncState(object):
  """
   This structure encapsulates the information about the state of the
   user's account for the purpose of "state based" synchronization.
  <dl>
   <dt>currentTime</dt>
     <dd>
     The server's current date and time.
     </dd>
  
   <dt>fullSyncBefore</dt>
     <dd>
     The cutoff date and time for client caches to be
     updated via incremental synchronization.  Any clients that were last
     synched with the server before this date/time must do a full resync of all
     objects.  This cutoff point will change over time as archival data is
     deleted or special circumstances on the service require resynchronization.
     </dd>
  
   <dt>updateCount</dt>
     <dd>
     Indicates the total number of transactions that have
     been committed within the account.  This reflects (for example) the
     number of discrete additions or modifications that have been made to
     the data in this account (tags, notes, resources, etc.).
     This number is the "high water mark" for Update Sequence Numbers (USN)
     within the account.
     </dd>
  
   <dt>uploaded</dt>
     <dd>
     The total number of bytes that have been uploaded to
     this account in the current monthly period.  This can be compared against
     Accounting.uploadLimit (from the UserStore) to determine how close the user
     is to their monthly upload limit.
     This value may not be present if the SyncState has been retrieved by
     a caller that only has read access to the account.
     </dd>
   </dl>
  
  Attributes:
   - currentTime
   - fullSyncBefore
   - updateCount
   - uploaded
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'currentTime', None, None, ), # 1
    (2, TType.I64, 'fullSyncBefore', None, None, ), # 2
    (3, TType.I32, 'updateCount', None, None, ), # 3
    (4, TType.I64, 'uploaded', None, None, ), # 4
  )

  def __init__(self, currentTime=None, fullSyncBefore=None, updateCount=None, uploaded=None,):
    self.currentTime = currentTime
    self.fullSyncBefore = fullSyncBefore
    self.updateCount = updateCount
    self.uploaded = uploaded

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.currentTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.fullSyncBefore = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.uploaded = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SyncState')
    if self.currentTime != None:
      oprot.writeFieldBegin('currentTime', TType.I64, 1)
      oprot.writeI64(self.currentTime)
      oprot.writeFieldEnd()
    if self.fullSyncBefore != None:
      oprot.writeFieldBegin('fullSyncBefore', TType.I64, 2)
      oprot.writeI64(self.fullSyncBefore)
      oprot.writeFieldEnd()
    if self.updateCount != None:
      oprot.writeFieldBegin('updateCount', TType.I32, 3)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    if self.uploaded != None:
      oprot.writeFieldBegin('uploaded', TType.I64, 4)
      oprot.writeI64(self.uploaded)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SyncChunk(object):
  """
   This structure is given out by the NoteStore when a client asks to
   receive the current state of an account.  The client asks for the server's
   state one chunk at a time in order to allow clients to retrieve the state
   of a large account without needing to transfer the entire account in
   a single message.
  
   The server always gives SyncChunks using an ascending series of Update
   Sequence Numbers (USNs).
  
  <dl>
   <dt>currentTime</dt>
     <dd>
     The server's current date and time.
     </dd>
  
   <dt>chunkHighUSN</dt>
     <dd>
     The highest USN for any of the data objects represented
     in this sync chunk.  If there are no objects in the chunk, this will not be
     set.
     </dd>
  
   <dt>updateCount</dt>
     <dd>
     The total number of updates that have been performed in
     the service for this account.  This is equal to the highest USN within the
     account at the point that this SyncChunk was generated.  If updateCount
     and chunkHighUSN are identical, that means that this is the last chunk
     in the account ... there is no more recent information.
     </dd>
  
   <dt>notes</dt>
     <dd>
     If present, this is a list of non-expunged notes that
     have a USN in this chunk.  This will include notes that are "deleted"
     but not expunged (i.e. in the trash).  The notes will include their list
     of tags and resources, but the resource content and recognition data
     will not be supplied.
     </dd>
  
   <dt>notebooks</dt>
     <dd>
     If present, this is a list of non-expunged notebooks that
     have a USN in this chunk.  This will include notebooks that are "deleted"
     but not expunged (i.e. in the trash).
     </dd>
  
   <dt>tags</dt>
     <dd>
     If present, this is a list of the non-expunged tags that have a
     USN in this chunk.
     </dd>
  
   <dt>searches</dt>
     <dd>
     If present, this is a list of non-expunged searches that
     have a USN in this chunk.
     </dd>
  
   <dt>resources</dt>
     <dd>
     If present, this is a list of the non-expunged resources
     that have a USN in this chunk.  This will include the metadata for each
     resource, but not its binary contents or recognition data, which must be
     retrieved separately.
     </dd>
  
   <dt>expungedNotes</dt>
     <dd>
     If present, the GUIDs of all of the notes that were
     permanently expunged in this chunk.
     </dd>
  
   <dt>expungedNotebooks</dt>
     <dd>
     If present, the GUIDs of all of the notebooks that
     were permanently expunged in this chunk.  When a notebook is expunged,
     this implies that all of its child notes (and their resources) were
     also expunged.
     </dd>
  
   <dt>expungedTags</dt>
     <dd>
     If present, the GUIDs of all of the tags that were
     permanently expunged in this chunk.
     </dd>
  
   <dt>expungedSearches</dt>
     <dd>
     If present, the GUIDs of all of the saved searches
     that were permanently expunged in this chunk.
     </dd>
  
   <dt>linkedNotebooks</dt>
     <dd>
     If present, this is a list of non-expunged LinkedNotebooks that
     have a USN in this chunk.
     </dd>
  
   <dt>expungedLinkedNotebooks</dt>
     <dd>
     If present, the GUIDs of all of the LinkedNotebooks
     that were permanently expunged in this chunk.
     </dd>
   </dl>
  
  Attributes:
   - currentTime
   - chunkHighUSN
   - updateCount
   - notes
   - notebooks
   - tags
   - searches
   - resources
   - expungedNotes
   - expungedNotebooks
   - expungedTags
   - expungedSearches
   - linkedNotebooks
   - expungedLinkedNotebooks
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'currentTime', None, None, ), # 1
    (2, TType.I32, 'chunkHighUSN', None, None, ), # 2
    (3, TType.I32, 'updateCount', None, None, ), # 3
    (4, TType.LIST, 'notes', (TType.STRUCT,(evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'notebooks', (TType.STRUCT,(evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'tags', (TType.STRUCT,(evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'searches', (TType.STRUCT,(evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec)), None, ), # 7
    (8, TType.LIST, 'resources', (TType.STRUCT,(evernote.edam.type.ttypes.Resource, evernote.edam.type.ttypes.Resource.thrift_spec)), None, ), # 8
    (9, TType.LIST, 'expungedNotes', (TType.STRING,None), None, ), # 9
    (10, TType.LIST, 'expungedNotebooks', (TType.STRING,None), None, ), # 10
    (11, TType.LIST, 'expungedTags', (TType.STRING,None), None, ), # 11
    (12, TType.LIST, 'expungedSearches', (TType.STRING,None), None, ), # 12
    (13, TType.LIST, 'linkedNotebooks', (TType.STRUCT,(evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec)), None, ), # 13
    (14, TType.LIST, 'expungedLinkedNotebooks', (TType.STRING,None), None, ), # 14
  )

  def __init__(self, currentTime=None, chunkHighUSN=None, updateCount=None, notes=None, notebooks=None, tags=None, searches=None, resources=None, expungedNotes=None, expungedNotebooks=None, expungedTags=None, expungedSearches=None, linkedNotebooks=None, expungedLinkedNotebooks=None,):
    self.currentTime = currentTime
    self.chunkHighUSN = chunkHighUSN
    self.updateCount = updateCount
    self.notes = notes
    self.notebooks = notebooks
    self.tags = tags
    self.searches = searches
    self.resources = resources
    self.expungedNotes = expungedNotes
    self.expungedNotebooks = expungedNotebooks
    self.expungedTags = expungedTags
    self.expungedSearches = expungedSearches
    self.linkedNotebooks = linkedNotebooks
    self.expungedLinkedNotebooks = expungedLinkedNotebooks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.currentTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.chunkHighUSN = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.notes = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = evernote.edam.type.ttypes.Note()
            _elem5.read(iprot)
            self.notes.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.notebooks = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = evernote.edam.type.ttypes.Notebook()
            _elem11.read(iprot)
            self.notebooks.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.tags = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = evernote.edam.type.ttypes.Tag()
            _elem17.read(iprot)
            self.tags.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.searches = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in xrange(_size18):
            _elem23 = evernote.edam.type.ttypes.SavedSearch()
            _elem23.read(iprot)
            self.searches.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.resources = []
          (_etype27, _size24) = iprot.readListBegin()
          for _i28 in xrange(_size24):
            _elem29 = evernote.edam.type.ttypes.Resource()
            _elem29.read(iprot)
            self.resources.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.expungedNotes = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readString();
            self.expungedNotes.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.expungedNotebooks = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = iprot.readString();
            self.expungedNotebooks.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.expungedTags = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString();
            self.expungedTags.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.expungedSearches = []
          (_etype51, _size48) = iprot.readListBegin()
          for _i52 in xrange(_size48):
            _elem53 = iprot.readString();
            self.expungedSearches.append(_elem53)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.linkedNotebooks = []
          (_etype57, _size54) = iprot.readListBegin()
          for _i58 in xrange(_size54):
            _elem59 = evernote.edam.type.ttypes.LinkedNotebook()
            _elem59.read(iprot)
            self.linkedNotebooks.append(_elem59)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.expungedLinkedNotebooks = []
          (_etype63, _size60) = iprot.readListBegin()
          for _i64 in xrange(_size60):
            _elem65 = iprot.readString();
            self.expungedLinkedNotebooks.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SyncChunk')
    if self.currentTime != None:
      oprot.writeFieldBegin('currentTime', TType.I64, 1)
      oprot.writeI64(self.currentTime)
      oprot.writeFieldEnd()
    if self.chunkHighUSN != None:
      oprot.writeFieldBegin('chunkHighUSN', TType.I32, 2)
      oprot.writeI32(self.chunkHighUSN)
      oprot.writeFieldEnd()
    if self.updateCount != None:
      oprot.writeFieldBegin('updateCount', TType.I32, 3)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    if self.notes != None:
      oprot.writeFieldBegin('notes', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter66 in self.notes:
        iter66.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.notebooks != None:
      oprot.writeFieldBegin('notebooks', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.notebooks))
      for iter67 in self.notebooks:
        iter67.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter68 in self.tags:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.searches != None:
      oprot.writeFieldBegin('searches', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.searches))
      for iter69 in self.searches:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.resources != None:
      oprot.writeFieldBegin('resources', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.resources))
      for iter70 in self.resources:
        iter70.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedNotes != None:
      oprot.writeFieldBegin('expungedNotes', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.expungedNotes))
      for iter71 in self.expungedNotes:
        oprot.writeString(iter71)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedNotebooks != None:
      oprot.writeFieldBegin('expungedNotebooks', TType.LIST, 10)
      oprot.writeListBegin(TType.STRING, len(self.expungedNotebooks))
      for iter72 in self.expungedNotebooks:
        oprot.writeString(iter72)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedTags != None:
      oprot.writeFieldBegin('expungedTags', TType.LIST, 11)
      oprot.writeListBegin(TType.STRING, len(self.expungedTags))
      for iter73 in self.expungedTags:
        oprot.writeString(iter73)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedSearches != None:
      oprot.writeFieldBegin('expungedSearches', TType.LIST, 12)
      oprot.writeListBegin(TType.STRING, len(self.expungedSearches))
      for iter74 in self.expungedSearches:
        oprot.writeString(iter74)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.linkedNotebooks != None:
      oprot.writeFieldBegin('linkedNotebooks', TType.LIST, 13)
      oprot.writeListBegin(TType.STRUCT, len(self.linkedNotebooks))
      for iter75 in self.linkedNotebooks:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedLinkedNotebooks != None:
      oprot.writeFieldBegin('expungedLinkedNotebooks', TType.LIST, 14)
      oprot.writeListBegin(TType.STRING, len(self.expungedLinkedNotebooks))
      for iter76 in self.expungedLinkedNotebooks:
        oprot.writeString(iter76)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteFilter(object):
  """
   A list of criteria that are used to indicate which notes are desired from
   the account.  This is used in queries to the NoteStore to determine
   which notes should be retrieved.
  
  <dl>
   <dt>order</dt>
     <dd>
     The NoteSortOrder value indicating what criterion should be
     used to sort the results of the filter.
     </dd>
  
   <dt>ascending</dt>
     <dd>
     If true, the results will be ascending in the requested
     sort order.  If false, the results will be descending.
     </dd>
  
   <dt>words</dt>
     <dd>
     The string query containing keywords to match, if present.
     </dd>
  
   <dt>notebookGuid</dt>
     <dd>
     If present, the Guid of the notebook that must contain
     the notes.
     </dd>
  
   <dt>tagGuids</dt>
     <dd>
     If present, the list of tags (by GUID) that must be present
     on the notes.
     </dd>
  
   <dt>timeZone</dt>
     <dd>
     The zone ID for the user, which will be used to interpret
     any dates or times in the queries that do not include their desired zone
     information.
     For example, if a query requests notes created "yesterday", this
     will be evaluated from the provided time zone, if provided.
     The format must be encoded as a standard zone ID such as
     "America/Los_Angeles".
     </dd>
  
   <dt>inactive</dt>
     <dd>
     If true, then only notes that are not active (i.e. notes in
     the Trash) will be returned. Otherwise, only active notes will be returned.
     There is no way to find both active and inactive notes in a single query.
     </dd>
   </dl>
  
  Attributes:
   - order
   - ascending
   - words
   - notebookGuid
   - tagGuids
   - timeZone
   - inactive
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'order', None, None, ), # 1
    (2, TType.BOOL, 'ascending', None, None, ), # 2
    (3, TType.STRING, 'words', None, None, ), # 3
    (4, TType.STRING, 'notebookGuid', None, None, ), # 4
    (5, TType.LIST, 'tagGuids', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'timeZone', None, None, ), # 6
    (7, TType.BOOL, 'inactive', None, None, ), # 7
  )

  def __init__(self, order=None, ascending=None, words=None, notebookGuid=None, tagGuids=None, timeZone=None, inactive=None,):
    self.order = order
    self.ascending = ascending
    self.words = words
    self.notebookGuid = notebookGuid
    self.tagGuids = tagGuids
    self.timeZone = timeZone
    self.inactive = inactive

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.order = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.ascending = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.words = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.tagGuids = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readString();
            self.tagGuids.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.timeZone = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.inactive = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteFilter')
    if self.order != None:
      oprot.writeFieldBegin('order', TType.I32, 1)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    if self.ascending != None:
      oprot.writeFieldBegin('ascending', TType.BOOL, 2)
      oprot.writeBool(self.ascending)
      oprot.writeFieldEnd()
    if self.words != None:
      oprot.writeFieldBegin('words', TType.STRING, 3)
      oprot.writeString(self.words)
      oprot.writeFieldEnd()
    if self.notebookGuid != None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 4)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.tagGuids != None:
      oprot.writeFieldBegin('tagGuids', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.tagGuids))
      for iter83 in self.tagGuids:
        oprot.writeString(iter83)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timeZone != None:
      oprot.writeFieldBegin('timeZone', TType.STRING, 6)
      oprot.writeString(self.timeZone)
      oprot.writeFieldEnd()
    if self.inactive != None:
      oprot.writeFieldBegin('inactive', TType.BOOL, 7)
      oprot.writeBool(self.inactive)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteList(object):
  """
   A small structure for returning a list of notes out of a larger set.
  
  <dl>
   <dt>startIndex</dt>
     <dd>
     The starting index within the overall set of notes.  This
     is also the number of notes that are "before" this list in the set.
     </dd>
  
   <dt>totalNotes</dt>
     <dd>
     The number of notes in the larger set.  This can be used
     to calculate how many notes are "after" this note in the set.
     (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
     </dd>
  
   <dt>notes</dt>
     <dd>
     The list of notes from this range.  The Notes will include all
     metadata (attributes, resources, etc.), but will not include the ENML
     content of the note or the binary contents of any resources.
     </dd>
  
   <dt>stoppedWords</dt>
     <dd>
     If the NoteList was produced using a text based search
     query that included words that are not indexed or searched by the service,
     this will include a list of those ignored words.
     </dd>
  
   <dt>searchedWords</dt>
     <dd>
     If the NoteList was produced using a text based search
     query that included viable search words or quoted expressions, this will
     include a list of those words.  Any stopped words will not be included
     in this list.
     </dd>
  
   <dt>updateCount</dt>
     <dd>
     Indicates the total number of transactions that have
     been committed within the account.  This reflects (for example) the
     number of discrete additions or modifications that have been made to
     the data in this account (tags, notes, resources, etc.).
     This number is the "high water mark" for Update Sequence Numbers (USN)
     within the account.
     </dd>
   </dl>
  
  Attributes:
   - startIndex
   - totalNotes
   - notes
   - stoppedWords
   - searchedWords
   - updateCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'startIndex', None, None, ), # 1
    (2, TType.I32, 'totalNotes', None, None, ), # 2
    (3, TType.LIST, 'notes', (TType.STRUCT,(evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'stoppedWords', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'searchedWords', (TType.STRING,None), None, ), # 5
    (6, TType.I32, 'updateCount', None, None, ), # 6
  )

  def __init__(self, startIndex=None, totalNotes=None, notes=None, stoppedWords=None, searchedWords=None, updateCount=None,):
    self.startIndex = startIndex
    self.totalNotes = totalNotes
    self.notes = notes
    self.stoppedWords = stoppedWords
    self.searchedWords = searchedWords
    self.updateCount = updateCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.startIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.totalNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.notes = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = evernote.edam.type.ttypes.Note()
            _elem89.read(iprot)
            self.notes.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.stoppedWords = []
          (_etype93, _size90) = iprot.readListBegin()
          for _i94 in xrange(_size90):
            _elem95 = iprot.readString();
            self.stoppedWords.append(_elem95)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.searchedWords = []
          (_etype99, _size96) = iprot.readListBegin()
          for _i100 in xrange(_size96):
            _elem101 = iprot.readString();
            self.searchedWords.append(_elem101)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteList')
    if self.startIndex != None:
      oprot.writeFieldBegin('startIndex', TType.I32, 1)
      oprot.writeI32(self.startIndex)
      oprot.writeFieldEnd()
    if self.totalNotes != None:
      oprot.writeFieldBegin('totalNotes', TType.I32, 2)
      oprot.writeI32(self.totalNotes)
      oprot.writeFieldEnd()
    if self.notes != None:
      oprot.writeFieldBegin('notes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter102 in self.notes:
        iter102.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stoppedWords != None:
      oprot.writeFieldBegin('stoppedWords', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.stoppedWords))
      for iter103 in self.stoppedWords:
        oprot.writeString(iter103)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.searchedWords != None:
      oprot.writeFieldBegin('searchedWords', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.searchedWords))
      for iter104 in self.searchedWords:
        oprot.writeString(iter104)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.updateCount != None:
      oprot.writeFieldBegin('updateCount', TType.I32, 6)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteCollectionCounts(object):
  """
   A data structure representing the number of notes for each notebook
   and tag with a non-zero set of applicable notes.
  
  <dl>
   <dt>notebookCounts</dt>
     <dd>
     A mapping from the Notebook GUID to the number of
     notes (from some selection) that are in the corresponding notebook.
     </dd>
  
   <dt>tagCounts</dt>
     <dd>
     A mapping from the Tag GUID to the number of notes (from some
     selection) that have the corresponding tag.
     </dd>
  
   <dt>trashCount</dt>
     <dd>
     If this is set, then this is the number of notes that are in the trash.
     If this is not set, then the number of notes in the trash hasn't been
     reported.  (I.e. if there are no notes in the trash, this will be set
     to 0.)
     </dd>
   </dl>
  
  Attributes:
   - notebookCounts
   - tagCounts
   - trashCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'notebookCounts', (TType.STRING,None,TType.I32,None), None, ), # 1
    (2, TType.MAP, 'tagCounts', (TType.STRING,None,TType.I32,None), None, ), # 2
    (3, TType.I32, 'trashCount', None, None, ), # 3
  )

  def __init__(self, notebookCounts=None, tagCounts=None, trashCount=None,):
    self.notebookCounts = notebookCounts
    self.tagCounts = tagCounts
    self.trashCount = trashCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.notebookCounts = {}
          (_ktype106, _vtype107, _size105 ) = iprot.readMapBegin() 
          for _i109 in xrange(_size105):
            _key110 = iprot.readString();
            _val111 = iprot.readI32();
            self.notebookCounts[_key110] = _val111
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.tagCounts = {}
          (_ktype113, _vtype114, _size112 ) = iprot.readMapBegin() 
          for _i116 in xrange(_size112):
            _key117 = iprot.readString();
            _val118 = iprot.readI32();
            self.tagCounts[_key117] = _val118
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.trashCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteCollectionCounts')
    if self.notebookCounts != None:
      oprot.writeFieldBegin('notebookCounts', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.notebookCounts))
      for kiter119,viter120 in self.notebookCounts.items():
        oprot.writeString(kiter119)
        oprot.writeI32(viter120)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.tagCounts != None:
      oprot.writeFieldBegin('tagCounts', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.tagCounts))
      for kiter121,viter122 in self.tagCounts.items():
        oprot.writeString(kiter121)
        oprot.writeI32(viter122)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.trashCount != None:
      oprot.writeFieldBegin('trashCount', TType.I32, 3)
      oprot.writeI32(self.trashCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AdImpressions(object):
  """
  Information for tracking the display of a particular ad by a client.
  
  <dl>
   <dt>adId</dt>
     <dd>
       The identifier for this ad, from a previous Ad.id given to the client
     </dd>
  
   <dt>impressionCount</dt>
     <dd>
       The number of times this ad was displayed since the last successful
       ad retrieval.  The client should only report times the ad was selected
       when the client was visible.
     </dd>
  
   <dt>impressionTime</dt>
     <dd>
       The number of seconds that the client displayed the advertisement since
       the last successful ad retrieval.  This corresponds to the seconds that
       the client application was visible.
     </dd>
  </dl>
  
  Attributes:
   - adId
   - impressionCount
   - impressionTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'adId', None, None, ), # 1
    (2, TType.I32, 'impressionCount', None, None, ), # 2
    (3, TType.I32, 'impressionTime', None, None, ), # 3
  )

  def __init__(self, adId=None, impressionCount=None, impressionTime=None,):
    self.adId = adId
    self.impressionCount = impressionCount
    self.impressionTime = impressionTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.adId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.impressionCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.impressionTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AdImpressions')
    if self.adId != None:
      oprot.writeFieldBegin('adId', TType.I32, 1)
      oprot.writeI32(self.adId)
      oprot.writeFieldEnd()
    if self.impressionCount != None:
      oprot.writeFieldBegin('impressionCount', TType.I32, 2)
      oprot.writeI32(self.impressionCount)
      oprot.writeFieldEnd()
    if self.impressionTime != None:
      oprot.writeFieldBegin('impressionTime', TType.I32, 3)
      oprot.writeI32(self.impressionTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AdParameters(object):
  """
  Parameters that will be given by a client to the service when it requests
  a set of advertisements to display.  If any of these values are omitted,
  the service will use default values.
  
  <dl>
   <dt>clientLanguage</dt>
     <dd>
       The ISO 639-1 language code for the primary language for the client.
       If omitted, English will be assumed ('en').
     </dd>
  
   <dt>impressions</dt>
     <dd>
       A list of the impression counts and total display time for the ads
       that were displayed in the last day.
     </dd>
  
   <dt>supportHtml</dt>
     <dd>
       If true, the client requesting the ads supports ads specified via
       general HTML (with rich media, Javascript, etc.).
     </dd>
  
   <dt>clientProperties</dt>
     <dd>
       If provided, this may contain a set of key/value pairs that identify
       the characteristics of a particular client that may be used to help
       determine appropriate ads for that client.  These tuples may be used
       either to reduce or increase the likelihood that each ad will be
       returned.
     </dd>
  </dl>
  
  Attributes:
   - clientLanguage
   - impressions
   - supportHtml
   - clientProperties
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'clientLanguage', None, None, ), # 2
    None, # 3
    (4, TType.LIST, 'impressions', (TType.STRUCT,(AdImpressions, AdImpressions.thrift_spec)), None, ), # 4
    (5, TType.BOOL, 'supportHtml', None, None, ), # 5
    (6, TType.MAP, 'clientProperties', (TType.STRING,None,TType.STRING,None), None, ), # 6
  )

  def __init__(self, clientLanguage=None, impressions=None, supportHtml=None, clientProperties=None,):
    self.clientLanguage = clientLanguage
    self.impressions = impressions
    self.supportHtml = supportHtml
    self.clientProperties = clientProperties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.clientLanguage = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.impressions = []
          (_etype126, _size123) = iprot.readListBegin()
          for _i127 in xrange(_size123):
            _elem128 = AdImpressions()
            _elem128.read(iprot)
            self.impressions.append(_elem128)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.supportHtml = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.clientProperties = {}
          (_ktype130, _vtype131, _size129 ) = iprot.readMapBegin() 
          for _i133 in xrange(_size129):
            _key134 = iprot.readString();
            _val135 = iprot.readString();
            self.clientProperties[_key134] = _val135
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AdParameters')
    if self.clientLanguage != None:
      oprot.writeFieldBegin('clientLanguage', TType.STRING, 2)
      oprot.writeString(self.clientLanguage)
      oprot.writeFieldEnd()
    if self.impressions != None:
      oprot.writeFieldBegin('impressions', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.impressions))
      for iter136 in self.impressions:
        iter136.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.supportHtml != None:
      oprot.writeFieldBegin('supportHtml', TType.BOOL, 5)
      oprot.writeBool(self.supportHtml)
      oprot.writeFieldEnd()
    if self.clientProperties != None:
      oprot.writeFieldBegin('clientProperties', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.clientProperties))
      for kiter137,viter138 in self.clientProperties.items():
        oprot.writeString(kiter137)
        oprot.writeString(viter138)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteEmailParameters(object):
  """
  Parameters that must be given to the NoteStore emailNote call. These allow
  the caller to specify the note to send, the recipient addresses, etc.
  
  <dl>
   <dt>guid</dt>
     <dd>
       If set, this must be the GUID of a note within the user's account that
       should be retrieved from the service and sent as email.  If not set,
       the 'note' field must be provided instead.
     </dd>
  
   <dt>note</dt>
     <dd>
       If the 'guid' field is not set, this field must be provided, including
       the full contents of the note note (and all of its Resources) to send.
       This can be used for a Note that as not been created in the service,
       for example by a local client with local notes.
     </dd>
  
   <dt>toAddresses</dt>
     <dd>
       If provided, this should contain a list of the SMTP email addresses
       that should be included in the "To:" line of the email.
       Callers must specify at least one "to" or "cc" email address.
     </dd>
  
   <dt>ccAddresses</dt>
     <dd>
       If provided, this should contain a list of the SMTP email addresses
       that should be included in the "Cc:" line of the email.
       Callers must specify at least one "to" or "cc" email address.
     </dd>
  
   <dt>subject</dt>
     <dd>
       If provided, this should contain the subject line of the email that
       will be sent.  If not provided, the title of the note will be used
       as the subject of the email.
     </dd>
  
   <dt>message</dt>
     <dd>
       If provided, this is additional personal text that should be included
       into the email as a message from the owner to the recipient(s).
     </dd>
  </dl>
  
  Attributes:
   - guid
   - note
   - toAddresses
   - ccAddresses
   - subject
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRUCT, 'note', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 2
    (3, TType.LIST, 'toAddresses', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'ccAddresses', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'subject', None, None, ), # 5
    (6, TType.STRING, 'message', None, None, ), # 6
  )

  def __init__(self, guid=None, note=None, toAddresses=None, ccAddresses=None, subject=None, message=None,):
    self.guid = guid
    self.note = note
    self.toAddresses = toAddresses
    self.ccAddresses = ccAddresses
    self.subject = subject
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.note = evernote.edam.type.ttypes.Note()
          self.note.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.toAddresses = []
          (_etype142, _size139) = iprot.readListBegin()
          for _i143 in xrange(_size139):
            _elem144 = iprot.readString();
            self.toAddresses.append(_elem144)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.ccAddresses = []
          (_etype148, _size145) = iprot.readListBegin()
          for _i149 in xrange(_size145):
            _elem150 = iprot.readString();
            self.ccAddresses.append(_elem150)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.subject = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteEmailParameters')
    if self.guid != None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.note != None:
      oprot.writeFieldBegin('note', TType.STRUCT, 2)
      self.note.write(oprot)
      oprot.writeFieldEnd()
    if self.toAddresses != None:
      oprot.writeFieldBegin('toAddresses', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.toAddresses))
      for iter151 in self.toAddresses:
        oprot.writeString(iter151)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccAddresses != None:
      oprot.writeFieldBegin('ccAddresses', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.ccAddresses))
      for iter152 in self.ccAddresses:
        oprot.writeString(iter152)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.subject != None:
      oprot.writeFieldBegin('subject', TType.STRING, 5)
      oprot.writeString(self.subject)
      oprot.writeFieldEnd()
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 6)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteVersionId(object):
  """
  Identfying information about previous versions of a note that are backed up
  within Evernote's servers.  Used in the return value of the listNoteVersions
  call.
  
  <dl>
   <dt>updateSequenceNum</dt>
   <dd>
     The update sequence number for the Note when it last had this content.
     This serves to uniquely identify each version of the note, since USN
     values are unique within an account for each update.
   </dd>
   <dt>updated</dt>
   <dd>
     The 'updated' time that was set on the Note when it had this version
     of the content.  This is the user-modifiable modification time on the
     note, so it's not reliable for guaranteeing the order of various
     versions.  (E.g. if someone modifies the note, then changes this time
     manually into the past and then updates the note again.)
   </dd>
   <dt>saved</dt>
   <dd>
     A timestamp that holds the date and time when this version of the note
     was backed up by Evernote's servers.  This
   </dd>
   <dt>title</dt>
   <dd>
     The title of the note when this particular verison was saved.  (The
     current title of the note may differ from this value.)
   </dd>
  </dl>
  
  Attributes:
   - updateSequenceNum
   - updated
   - saved
   - title
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'updateSequenceNum', None, None, ), # 1
    (2, TType.I64, 'updated', None, None, ), # 2
    (3, TType.I64, 'saved', None, None, ), # 3
    (4, TType.STRING, 'title', None, None, ), # 4
  )

  def __init__(self, updateSequenceNum=None, updated=None, saved=None, title=None,):
    self.updateSequenceNum = updateSequenceNum
    self.updated = updated
    self.saved = saved
    self.title = title

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.saved = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteVersionId')
    if self.updateSequenceNum != None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 1)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.updated != None:
      oprot.writeFieldBegin('updated', TType.I64, 2)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.saved != None:
      oprot.writeFieldBegin('saved', TType.I64, 3)
      oprot.writeI64(self.saved)
      oprot.writeFieldEnd()
    if self.title != None:
      oprot.writeFieldBegin('title', TType.STRING, 4)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

